
# VI_MODEL ----------------------------------------------------------------

class_VI_MODEL <- function(env = new.env(parent = parent.frame())) {

  # Pass CMD check
  .fitted <- .resid <- self <- NULL

  new_class(BASE, env = env, class_name = "VI_MODEL")

  env$prm <- list()
  env$prm_type <- list()

  # Define a place holder for cached model, data and null formula
  env$..cache.. <- list(dat = NULL, formula = NULL, mod = NULL)

# init --------------------------------------------------------------------

  init_ <- function(prm = list(), prm_type = list(), formula = self$formula, null_formula = NULL, alt_formula = NULL) {

    self$prm <- prm
    self$prm_type <- prm_type

    if (is.null(formula)) {
      stop("`formula` is missing! Unable to create `y`.")
    } else {

      # Update the formula
      self$set_formula(formula = formula,
                       null_formula = null_formula,
                       alt_formula = alt_formula)
    }

    # Get the quoted formula, and eval in the current environment
    formula <- eval(self$formula)

    # Assign values of `prm` into current environment
    list2env(prm, envir = environment())

    # Set the y variable
    self$prm$y <- visage::closed_form(formula, env = new.env(parent = parent.env(self)))
  }

# set_formula -------------------------------------------------------------

  set_formula_ <- function(...) {

    for_list <- list(...)
    name_for_list <- names(for_list)

    if (length(name_for_list) == 0) stop("No formula name is provided!")

    for (i in 1:length(for_list)) {
      if (name_for_list[i] == "") stop("Formula needs to be provided with a name")

      self[[name_for_list[i]]] <- for_list[[i]]
      attributes(self[[name_for_list[i]]]) <- NULL
    }
  }

# gen ---------------------------------------------------------------------

  gen_ <- function(n, fit_model = FALSE, test = FALSE) {

    # Generate the data frame from the expression
    dat <- visage::CLOSED_FORM$as_dataframe(self$prm$y$gen(n, rhs_val = TRUE), "y")

    # If requires residuals and fitted values, fit the model
    if (fit_model) {
      mod <- self$fit(dat)
      dat$.resid <- mod$residuals
      dat$.fitted <- mod$fitted.values
    }

    # If requires test statistics, get the test results
    if (test) {
      test_results <- self$test(dat)
      dat$test_name <- test_results$name
      dat$statistic <- test_results$statistic
      dat$p_value <- test_results$p_value
    }

    return(dat)
  }

# gen_lineup --------------------------------------------------------------

  gen_lineup_ <- function(n, k = 20, pos = NULL) {

    # Generate data with fitted values and residuals and test results
    dat <- self$gen(n, fit_model = TRUE, test = TRUE)

    # Get the model
    mod <- self$fit(dat)

    # Generate a random position for the true plot
    if (is.null(pos)) pos <- sample(1:k, 1)

    # Record the true position and mark it as true plot
    dat$k <- pos
    dat$null <- FALSE

    # Get a copy of the data frame
    newdat <- dat

    for (i in 1:k) {

      # Skip the true position
      if (i == pos) next

      # Combine the data frame generated by null_resid with the main data frame
      dat <- dplyr::bind_rows(dat, `[[<-`(self$null_resid(newdat, mod), "k", value = i))
    }

    return(dat)
  }


# null_resid --------------------------------------------------------------

  null_resid_ <- function(dat, mod, test = FALSE) {

    # Get the fitted values
    .fitted <- mod$fitted.values

    # Get the original RSS
    old_rss <- self$rss(mod)

    # Get the number of observations
    n <- length(.fitted)

    # Replace the regressand with random values
    dat$y <- stats::rnorm(n)

    # Update the model
    mod <- stats::update(mod, data = dat)

    # Update the residuals of the data frame
    dat$.resid <- mod$residuals * sqrt(old_rss/self$rss(mod))

    # Update the random y
    dat$y <- dat$.resid + .fitted

    # Get the test result from the updated data
    test_results <- self$test(dat)
    dat$test_name <- test_results$name
    dat$statistic <- test_results$statistic
    dat$p_value <- test_results$p_value

    # Label the data as null data
    dat$null <- TRUE

    return(dat)
  }


# rss ---------------------------------------------------------------------

  rss_ <- function(mod) sum(mod$residuals^2)


# fit ---------------------------------------------------------------------

  fit_ <- function(dat = self$..cache..$dat, formula = self$null_formula, cache = FALSE, ...) {

    if (is.null(formula)) stop("`formula` is missing! Can't fit the model.")

    # Get rid of the environment and class attributes in case it is a formula
    attributes(formula) <- NULL

    # If the dat is not provided and the formula is the same, then return the cached model
    if (cache && missing(dat) && (formula == self$..cache..$formula)) {
      return(self$..cache..$mod)
    }

    # Use `substitute` to let `lm` correctly record the call
    mod <- eval(substitute(stats::lm(formula = formula, data = dat, ...)))

    # Cache the model, data and the formula
    if (cache) {
      self$..cache..$mod <- mod
      self$..cache..$formula <- formula
      self$..cache..$dat <- dat
    }

    return(mod)
  }


# test --------------------------------------------------------------------

  test_ <- function(dat, null_formula = self$null_formula, alt_formula = self$alt_formula) {

    # Define the null model and the alternative model
    null_mod <- self$fit(dat, null_formula)
    alt_mod <- self$fit(dat, alt_formula)

    # Use F-test to test the null hypothesis
    F_test <- stats::anova(null_mod, alt_mod, test = "F")

    list(name = "F-test", statistic = F_test$F[2], p_value = F_test$`Pr(>F)`[2])
  }


# effect_size -------------------------------------------------------------

  effect_size_ <- function(...) {NA}


# plot_resid --------------------------------------------------------------

  plot_resid_ <- function(dat, alpha = 1, size = 0.5) {
    ggplot2::ggplot(dat) +
      ggplot2::geom_point(ggplot2::aes(.fitted, .resid), alpha = alpha, size = size)
  }


# plot_qq -----------------------------------------------------------------

  plot_qq_ <- function(dat) {
    ggplot2::ggplot(dat) +
      ggplot2::geom_qq_line(ggplot2::aes(sample = .resid)) +
      ggplot2::geom_qq(ggplot2::aes(sample = .resid))
  }


# plot --------------------------------------------------------------------

  plot_ <- function(dat,
                    type = "resid",
                    theme = ggplot2::theme_grey(),
                    alpha = 1,
                    size = 0.5,
                    remove_axis = FALSE,
                    remove_legend = FALSE,
                    remove_grid_line = FALSE,
                    add_zero_line = TRUE) {
    p <- switch(type,
                "resid" = self$plot_resid(dat, alpha, size),
                "qq" = self$plot_qq(dat)) +
      theme

    if (add_zero_line) {
      p <- p + ggplot2::geom_hline(yintercept = 0, col = "red")

      # Pop the last layers
      tmp <- p$layers[[length(p$layers)]]
      p$layers[[length(p$layers)]] <- NULL

      # Append the element back to the list
      p$layers <- append(list(tmp), p$layers)
    }

    if (remove_axis) p <- p + ggplot2::theme(axis.line = ggplot2::element_blank(),
                                             axis.ticks = ggplot2::element_blank(),
                                             axis.text.x = ggplot2::element_blank(),
                                             axis.text.y = ggplot2::element_blank(),
                                             axis.title.x = ggplot2::element_blank(),
                                             axis.title.y = ggplot2::element_blank())

    if (remove_legend) p <- p + ggplot2::theme(legend.position = "none")

    if (remove_grid_line) p <- p + ggplot2::theme(panel.grid.major = ggplot2::element_blank(),
                                                  panel.grid.minor = ggplot2::element_blank())

    return(p)
  }


# plot_lineup -------------------------------------------------------------

  plot_lineup_ <- function(dat, type = "resid", ...) {
    single_plot <- self$plot(dat, type, ...)
    single_plot +
      ggplot2::facet_wrap(~k)
  }

# str ---------------------------------------------------------------------


  str_ <- function() {

    if (!self$..instantiated..) {
      return(paste0("<", self$..type.., " class>"))
    }

    results <- visage::use_method(self$prm$y, visage::CLOSED_FORM$..str..)()
    results <- paste0("<", self$..type.., " object>\n ",
                      gsub("<CLOSED_FORM object>\n EXPR", "y", results, fixed = TRUE))

    for (i in names(self$prm_type)[self$prm_type == "o"]) results <- paste0(results, "\n  - ", i, ": ", self$prm[[i]])

    results
  }


# register_method ---------------------------------------------------------

  register_method(env,
                  ..init.. = init_,
                  ..str.. = str_,
                  set_formula = set_formula_,
                  gen = gen_,
                  test = test_,
                  fit = fit_,
                  effect_size = effect_size_,
                  plot_resid = plot_resid_,
                  plot_qq = plot_qq_,
                  plot = plot_,
                  plot_lineup = plot_lineup_,
                  rss = rss_,
                  null_resid = null_resid_,
                  gen_lineup = gen_lineup_)

  return(env)
}


# CUBIC_MODEL -------------------------------------------------------------

class_CUBIC_MODEL <- function(env = new.env(parent = parent.frame())) {

  # Pass CMD check
  self <- NULL

  new_class(VI_MODEL, env = env, class_name = "CUBIC_MODEL")

  # Run the `set_formula` method for the class
  env$set_formula(formula = y ~ 1 + (2-c) * x + c * z + a * (((2-c) * x)^2 + (c * z)^2) + b * (((2-c) * x)^3 + (c * z)^3) + e,
                  null_formula = y ~ x + z,
                  alt_formula = y ~ x + I(x^2) + I(x^3) + z + I(z^2) + I(z^3))

# init --------------------------------------------------------------------

  init_ <- function(a = 1, b = 1, c = 1, sigma = 1,
                    x = visage::rand_uniform(-1, 1, env = new.env(parent = parent.env(self))),
                    z = visage::rand_uniform(-1, 1, env = new.env(parent = parent.env(self))),
                    e = visage::rand_normal(0, sigma, env = new.env(parent = parent.env(self)))) {

    # Use the init method from the VI_MODEL class
    visage::use_method(self, visage::VI_MODEL$..init..)(
      prm = list(a = a, b = b, c = c, sigma = sigma, x = x, z = z, e = e),
      prm_type = list(a = "o", b = "o", c = "o", sigma = "o", x = "r", z = "r", e = "r"),
      formula = self$formula,
      null_formula = self$null_formula,
      alt_formula = self$alt_formula
      )
  }


# E -----------------------------------------------------------------------

  E_ <- function(dat) {
    a <- self$prm$a
    b <- self$prm$b
    c <- self$prm$c
    Xa <- as.matrix(data.frame(1, dat$x, dat$z))
    Ra <- diag(nrow(dat)) - Xa %*% solve(t(Xa) %*% Xa) %*% t(Xa)
    Xb <- as.matrix(data.frame(dat$x^2, dat$z^2, dat$x^3, dat$z^3))
    beta_b <- matrix(c(a*(2-c)^2, a*c^2, b*(2-c)^3, b*c^3))

    c(Ra %*% Xb %*% beta_b)
  }


# effect_size -------------------------------------------------------------

  effect_size_ <- function(dat,
                           a = self$prm$a,
                           b = self$prm$b,
                           c = self$prm$c,
                           sigma = self$prm$sigma) {

    Xa <- as.matrix(data.frame(1, dat$x, dat$z))
    Ra <- diag(nrow(dat)) - Xa %*% solve(t(Xa) %*% Xa) %*% t(Xa)
    Xb <- as.matrix(data.frame(dat$x^2, dat$z^2, dat$x^3, dat$z^3))
    beta_b <- matrix(c(a*(2-c)^2, a*c^2, b*(2-c)^3, b*c^3))

    (1/nrow(dat)) * (1/sigma^2) * sum((diag(sqrt(diag(Ra))) %*% Xb %*% beta_b)^2)
  }

# register_method ---------------------------------------------------------

  register_method(env, ..init.. = init_, E = E_, effect_size = effect_size_)

  return(env)
}

# HETER_MODEL -------------------------------------------------------------


class_HETER_MODEL <- function(env = new.env(parent = parent.frame())) {

  # Pass CMD check
  self <- NULL

  new_class(VI_MODEL, env = env, class_name = "HETER_MODEL")

  # Run the `set_formula` method for the class
  env$set_formula(formula = y ~ 1 + x + e,
                  null_formula = y ~ x,
                  alt_formula = NULL,
                  sigma_formula = sigma ~ sqrt(1 + (2 - abs(a)) * (x - a)^2 * b),
                  e_formula = e ~ RAND_NORMAL[["gen"]](length(sigma), mu = 0, sigma = sigma))

# init --------------------------------------------------------------------

  init_ <- function(a = 0, b = 1,
                    x = visage::rand_uniform(-1, 1, env = new.env(parent = parent.env(self)))) {

    # `sigma` is a random variable which depends on `x`
    sigma <- visage::closed_form(eval(self$sigma_formula), env = new.env(parent = parent.env(self)))

    RAND_NORMAL <- visage::RAND_NORMAL

    # `e` is a random variable which depends on `sigma`
    e <- visage::closed_form(eval(self$e_formula), env = new.env(parent = parent.env(self)))

    # Use the init method from the VI_MODEL class
    visage::use_method(self, visage::VI_MODEL$..init..)(
      prm = list(a = a, b = b, x = x, sigma = sigma, e = e),
      prm_type = list(a = "o", b = "o", x = "r", sigma = "r", e = "r"),
      formula = self$formula,
      null_formula = self$null_formula,
      alt_formula = self$alt_formula
    )
  }


# test --------------------------------------------------------------------

  test_ <- function(dat, null_formula = self$null_formula) {

    # Get the null model
    mod <- self$fit(dat)

    # construct proxy variables
    tmp_data <- data.frame(x = dat$x)
    tmp_data$xs <- tmp_data$x^2

    # Run the BP test
    bp_test <- lmtest::bptest(mod, varformula = ~ x + xs, data = tmp_data)

    return(list(name = "BP-test",
                statistic = unname(bp_test$statistic),
                p_value = unname(bp_test$p.value)))
  }


# effect_size -------------------------------------------------------------

  effect_size_ <- function(dat, b = self$prm$b) {
    sqrt(nrow(dat)) * b
  }


# register_method ---------------------------------------------------------

  register_method(env, ..init.. = init_, test = test_, effect_size = effect_size_)

  return(env)
}
