
# VI_MODEL ----------------------------------------------------------------

class_VI_MODEL <- function(env = new.env(parent = parent.frame())) {

  # Pass CMD check
  .fitted <- .resid <- self <- NULL

  new_class(BASE, env = env, class_name = "VI_MODEL")

  env$prm <- list()
  env$prm_type <- list()

  # Define a place holder for cached model, data and null formula
  env$..cache.. <- list(dat = NULL, formula = NULL, mod = NULL)

# init --------------------------------------------------------------------

  init_ <- function(formula = NULL, null_formula = NULL, alt_formula = NULL) {

    # Define DGP
    self$formula <- formula

    # Define wrong model fit
    self$null_formula <- null_formula

    # Define correct model fit
    self$alt_formula <- alt_formula

    environment(self$formula) <- self
    environment(self$null_formula) <- self
    environment(self$alt_formula) <- self
  }

# gen ---------------------------------------------------------------------

  gen_ <- function(n, fit_model = FALSE, test = FALSE) {

    # Generate the data frame containing y, x, z, e
    dat <- CLOSED_FORM$as_dataframe(self$prm$y$gen(n, rhs_val = TRUE), "y")

    # If requires residuals and fitted values, fit the model
    if (fit_model) {
      mod <- self$fit(dat)
      dat$.resid <- mod$residuals
      dat$.fitted <- mod$fitted.values
    }

    if (test) {
      test_results <- self$test(dat)
      dat$test_name <- test_results$name
      dat$statistic <- test_results$statistic
      dat$p_value <- test_results$p_value
    }

    return(dat)
  }

# gen_lineup --------------------------------------------------------------

  gen_lineup_ <- function(n, k = 20, pos = NULL) {

    # Generate data with fitted values and residuals
    dat <- self$gen(n, fit_model = TRUE)

    # Get the model
    mod <- self$fit(dat)

    # Generate a random position for the true plot
    if (is.null(pos)) pos <- sample(1:k, 1)

    # Record the true position and mark it as true plot
    dat$k <- pos
    dat$null <- FALSE

    # Get a copy of the data frame
    newdat <- dat

    for (i in 1:k) {

      # Skip the true position
      if (i == pos) next

      # Combine the data frame generated by null_resid with the main data frame
      dat <- dplyr::bind_rows(dat, `[[<-`(self$null_resid(newdat, mod), "k", value = i))
    }

    return(dat)
  }


# null_resid --------------------------------------------------------------

  null_resid_ <- function(dat, mod, test = FALSE) {

    # Get the fitted values
    .fitted <- mod$fitted.values

    # Get the number of observations
    n <- length(.fitted)

    # Replace the regressand with random values
    dat$y <- stats::rnorm(n)

    # Update the model
    mod <- stats::update(mod, data = dat)

    # Update the residuals of the data frame
    dat$.resid <- mod$residuals * sqrt(self$rss(mod)/self$rss(mod))

    # Update the random y
    dat$y <- dat$.resid + .fitted

    # Label the data as null data
    dat$null <- TRUE

    return(dat)
  }


# rss ---------------------------------------------------------------------

  rss_ <- function(mod) sum(mod$residuals^2)


# fit ---------------------------------------------------------------------

  fit_ <- function(dat = self$..cache..$dat, formula = self$null_formula, cache = FALSE, ...) {

    # If the dat is not provided and the formula is the same, then return the cached model
    if (missing(dat) && (formula == self$..cache..$formula) && cache) {
      return(self$..cache..$mod)
    }

    # Correct the environment of the formula
    environment(formula) <- environment()

    # Use `substitute` to let `lm` correctly record the call
    mod <- eval(substitute(stats::lm(formula = formula, data = dat, ...)))

    # Cache the model, data and the formula
    if (cache) {
      self$..cache..$mod <- mod
      self$..cache..$formula <- formula
      environment(self$..cache..$formula) <- self
      self$..cache..$dat <- dat
    }

    return(mod)
  }


# test --------------------------------------------------------------------

  test_ <- function(dat, null_formula = self$null_formula, alt_formula = self$alt_formula) {

    # Define the null model and the alternative model
    null_mod <- self$fit(dat, null_formula)
    alt_mod <- self$fit(dat, alt_formula)

    # Use F-test to test the null hypothesis
    F_test <- stats::anova(null_mod, alt_mod, test = "F")

    list(name = "F-test", statistic = F_test$F[2], p_value = F_test$`Pr(>F)`[2])
  }


# plot_resid --------------------------------------------------------------

  plot_resid_ <- function(dat) {
    ggplot2::ggplot(dat) +
      ggplot2::geom_point(ggplot2::aes(.fitted, .resid))
  }


# plot --------------------------------------------------------------------

  plot_ <- function(dat,
                    type = "resid",
                    theme = ggplot2::theme_grey(),
                    remove_axis = FALSE,
                    remove_legend = FALSE,
                    remove_grid_line = FALSE,
                    add_zero_line = TRUE) {
    p <- switch(type,
                "resid" = self$plot_resid(dat)) +
      theme

    if (add_zero_line) {
      p <- p + ggplot2::geom_hline(yintercept = 0, col = "red")

      # Pop the last layers
      tmp <- p$layers[[length(p$layers)]]
      p$layers[[length(p$layers)]] <- NULL

      # Append the element back to the list
      p$layers <- append(list(tmp), p$layers)
    }

    if (remove_axis) p <- p + ggplot2::theme(axis.line = ggplot2::element_blank(),
                                             axis.ticks = ggplot2::element_blank(),
                                             axis.text.x = ggplot2::element_blank(),
                                             axis.text.y = ggplot2::element_blank(),
                                             axis.title.x = ggplot2::element_blank(),
                                             axis.title.y = ggplot2::element_blank())

    if (remove_legend) p <- p + ggplot2::theme(legend.position = "none")

    if (remove_grid_line) p <- p + ggplot2::theme(panel.grid.major = ggplot2::element_blank(),
                                                  panel.grid.minor = ggplot2::element_blank())

    return(p)
  }


# plot_lineup -------------------------------------------------------------

  plot_lineup_ <- function(dat, type = "resid", ...) {
    single_plot <- self$plot(dat, type, ...)
    single_plot +
      ggplot2::facet_wrap(~k)
  }

  str_ <- function() {

    if (!self$..instantiated..) {
      return(paste0("<", self$..type.., " class>"))
    }

    results <- use_method(self$prm$y, CLOSED_FORM$..str..)()
    results <- paste0("<", self$..type.., " object>\n ",
                      gsub("<CLOSED_FORM object>\n EXPR", "y", results, fixed = TRUE))

    for (i in names(self$prm_type)[self$prm_type == "other"]) results <- paste0(results, "\n  - ", i, ": ", self$prm[[i]])

    results
  }


# register_method ---------------------------------------------------------

  register_method(env,
                  ..init.. = init_,
                  ..str.. = str_,
                  gen = gen_,
                  test = test_,
                  fit = fit_,
                  plot_resid = plot_resid_,
                  plot = plot_,
                  plot_lineup = plot_lineup_,
                  rss = rss_,
                  null_resid = null_resid_,
                  gen_lineup = gen_lineup_)

  return(env)
}


# HIGHER_ORDER_MODEL ------------------------------------------------------

class_HIGHER_ORDER_MODEL <- function(env = new.env(parent = parent.frame())) {

  # Pass CMD check
  self <- NULL

  new_class(VI_MODEL, env = env, class_name = "HIGHER_ORDER_MODEL")

  # Run the init method from VI_MODEL, but for the class
  use_method(env, VI_MODEL$..init..)(formula = y ~ 1 + (2-c) * x + c * z + a * (((2-c) * x)^2 + (c * z)^2) + b * (((2-c) * x)^3 + (c * z)^3) + e,
                                     null_formula = y ~ x + z,
                                     alt_formula = y ~ x + I(x^2) + I(x^3) + z + I(z^2) + I(z^3))

# init --------------------------------------------------------------------

  init_ <- function(a = 1, b = 1, c = 1,
                    x = rand_uniform(env = new.env(parent = parent.env(self))),
                    z = rand_uniform(env = new.env(parent = parent.env(self))),
                    e = rand_normal(env = new.env(parent = parent.env(self)))) {
    self$prm$a <- a
    self$prm_type$a <- "other"
    self$prm$b <- b
    self$prm_type$b <- "other"
    self$prm$c <- c
    self$prm_type$c <- "other"
    self$prm$x <- x
    self$prm_type$x <- "rand_var or closed_form"
    self$prm$z <- z
    self$prm_type$x <- "rand_var or closed_form"
    self$prm$e <- e
    self$prm_type$x <- "rand_var or closed_form"

    f <- self$formula
    environment(f) <- environment()
    self$prm$y <- closed_form(f, env = new.env(parent = parent.env(self)))
  }

# register_method ---------------------------------------------------------

  register_method(env, ..init.. = init_)

  return(env)
}
