---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# visage

<!-- badges: start -->
<!-- badges: end -->

The goal of visage is to provide an lightweight OOP system and a set of tools for running visual inference experiments.

## Installation

And the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("TengMCing/visage")
```

```{r}
library(visage)
```

## Usage of visual inference cubic linear model class `CUBIC_MODEL`

### Define a model

A visual inference cubic linear model is defined as:

```{r}
CUBIC_MODEL$formula
```

where `x` and `z` are random variables, `a`, `b` and `c` are parameters and `e` is the random error term.

`cubic_model()` is a cubic model class constructor, which takes arguments `a`, `b`, `c`, `sigma`, `x` and `z`, where the first four are numeric values defined above, and `x` and `z` are random variable instances created by the random variable abstract base class constructor `rand_var()`. If we would like `x` and `z` to be random uniform variables ranged from âˆ’1 to 1, it can be achieved by using the random uniform variable class constructor `rand_uniform()`. It only takes two arguments which are the lower bound and the upper bound of the support.

```{r}
mod <- cubic_model(a = -3, b = -3, c = 1, sigma = 1,
                   x = rand_uniform(-1, 1), z = rand_uniform(-1, 1))
mod
```


### Generate random values from the model

An instance of cubic model class contains methods of simulating data and making residual plot. Method `gen()` returns a data frame containing realizations of `x`, `z`, `y` and `e` simulated from the model. The number of realizations depends on the integer argument `n`. In addition, a null model will be fitted using the simulated data and residuals and fitted values will be included in the returned data frame.

The null model is defined as:

```{r}
CUBIC_MODEL$null_formula
```

Generates five realizations from the model:

```{r}
mod$gen(n = 5)
```

### Make a residual plot

Method `plot()` produce a `ggplot` object. It takes a data frame containing columns `.resid` and `.fitted` as input, along with a character argument type indicating the type of the data plot, and other aesthetic arguments such as size and alpha to control the appearance of the plot.

```{r}
mod$plot(mod$gen(n = 100), type = "resid", size = 1)
```

### Make a lineup

A lineup is a matrix of residual plots which can be produced by using the methods `gen_lineup()` and `plot_lineup()`. Method `gen_lineup()` takes the number of realizations `n` and the number of plots in a lineup `k` as inputs. Other than that, the method `plot_lineup()` has the same user interface as `plot()`.

Generate a lineup consists of 2 plots and 8 realizations:

```{r}
mod$gen_lineup(n = 8, k = 2)
```


Plot a lineup consists of 20 plots and 300 realizations: 

```{r}
mod$plot_lineup(mod$gen_lineup(n = 300, k = 20), type = "resid", alpha = 0.6)
```

## Usage of visual inference heteroskedasticity linear model class `HETER_MODEL`

A visual inference heteroskedasticity linear model is defined as:

```{r}
HETER_MODEL$formula
```

where `x` is random variables, `a`, `b` are parameters and `e` is the random error term.

Similar to the cubic model, the heteroskedasticity model could be built by the heteroskedasticity model class constructor `heter_model()`. This function takes three arguments as inputs, which are `a`, `b` and `x`. `a` and `b` are numeric parameters defined above. `x` needs to be a random variable object.

```{r}
mod <- heter_model(a = 0, b = 16, x = rand_uniform(-1, 1))

mod
```


Since both the cubic model class `CUBIC_MODEL` and the heteroskedasticity model class `HETER_MODEL` are inherited from the visual inference model class `VI_MODEL`, heteroskedasticity model object can be used in a similar way as cubic model object. The following codes give examples of the use of the object.

```{r}
mod$gen(n = 5)
```

```{r}
mod$plot(mod$gen(n = 300), type = "resid", size = 1)
```

```{r}
mod$plot_lineup(mod$gen_lineup(n = 300), alpha = 0.6)
```

## Basic usgae of `visage` OOP system

### Define a new class

A class can be defined with the `new_class` function. All positional arguments are for specifying parent classes, `BASE` is the base object class provided by the package, you don't need to manually specify it. But if you would like to have advanced behaviour, you can try to implement your own `object` class.  

Class name is mandatory and should be unique. 

```{r}
# You don't actually need to specify BASE here. This is only for demonstration.
DEMO <- new_class(BASE, class_name = "DEMO")
DEMO
```

The object is an environment containing some useful attributes and methods.

- `OBJECT$..type..` gives the current class name.
- `OBJECT$..class..` gives the current class name and parent class names.

```{r}
DEMO$..type..
DEMO$..class..
```

- `OBJECT$..dict..()` returns all names of attribute and method of the object.
- `OBJECT$..methods..()` returns all names of method of the object


```{r}
DEMO$..dict..()
DEMO$..methods..()
```

- `OBJECT$..str..()` returns a string representation of the object, which will be used by the S3 `print()` method. This method usually needs to be overridden in subclass to give short summary of the object. 

```{r}
DEMO$..str..()
```


### Register a method for the class

Methods can be registered by using `register_method()`. The first argument is the object you want to bind the function to, the rest of the positional arguments are for specifying method names and functions. The syntax is `method_name = function`.

You can choose to write inline function or pass pre-defined function. The associative environment of the function doesn't matter, it will be modified by the `register_method()` function. 

```{r}
pre_defined_fn <- function() 1 + 2

register_method(DEMO, inline_fn = function() 1 + 1, pre_defined_fn = pre_defined_fn)

DEMO$inline_fn()
DEMO$pre_defined_fn()
```

For method that needs to access the object itself, just simply use `self` in your method. It is an reference to the object. 

```{r}
DEMO$val <- 5

register_method(DEMO, get_val = function() self$val)

DEMO$get_val()
```

### Override the `..init..()` method

`..init..()` method is for instance initialization. To override the `..init..()` method, you need to use the `register_method()` to register it again.

```{r}
init <- function(first_name, employee_id) {
  self$first_name <- first_name
  self$employee_id <- employee_id
}

register_method(DEMO, ..init.. = init)
```

Now the class requires two two arguments `first_name` and `employee_id` to initialize the instance.

### Build an instance

To new and initialize an instance, you need to use the `instantiation()` method. The output will show it is an object.

```{r}
mike <- DEMO$instantiation("Mike", 25)
mike
```

`first_name` and `employee_id` are stored in the object because of the `..init..()` method.

```{r}
mike$first_name
mike$employee_id
```


### A complete workflow

It is recommend to write your class definition in a function to make debugging easier. The following example new a class `DEMO_2`, defines its own `..init..()` method, defines a `get_email()` function for retrieving the email address, defines its own `..str..()` method such that when we print the object, it will provide us with a nicely formatted summary.

`use_method` is used to run methods from other classes, which in this case, the `..str..()` method from the `BASE` class.

```{r}
class_DEMO_2 <- function(env = new.env(parent = parent.frame())) {
  
  new_class(env = env, class_name = "DEMO_2")
  
  init_ <- function(first_name, employee_id) {
    self$first_name <- first_name
    self$employee_id <- employee_id
  }
  
  get_email_ <- function() {
    paste0(self$first_name, "_", self$employee_id, "@company.com")
  }
  
  str_ <- function() {
    paste(use_method(self, BASE$..str..)(), 
          paste("Name:", self$first_name,
                "\nEmployee ID:", self$employee_id,
                "\nEmail:", self$get_email()), 
          sep = "\n")
  }
  
  register_method(env,
                  ..init.. = init_,
                  get_email = get_email_,
                  ..str.. = str_)
  
  return(env)
}
```


```{r}
DEMO_2 <- class_DEMO_2()
mike <- DEMO_2$instantiation("Mike", 25)
mike$get_email()
```

```{r}
mike$..str..()
mike
```
