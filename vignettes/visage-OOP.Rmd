---
title: "visage OOP system"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{visage-OOP}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

**OOP** has been heavily used in R via the S3 system. However, users who have learned OOP in other languages are often dissatisfied with its syntax. This vignette introduces an OOP system provided by the `visage` package, which tries to implement a lightweight OOP system with python-like syntax in R using the "environment" language feature. This OOP system is developed primarily for the ease of designing, simulating, and evaluating visual inference experiment. 

There is another OOP system in R called [R6](https://r6.r-lib.org/index.html), which is also implemented using environment but in a different way. 

# Structure of this vignette

The first section will review some essential concepts of OOP, if you are familiar with them, you can safely skip it.

# OOP concepts review

**OOP** stands for **object-oriented programming**, which is a programming paradigm based on **objects**. Usually, object is defined as a special type of data structure that can hold both **attributes** (data) and **methods** (associated behaviors). 

## Class and instance

- Different kinds of objects are designed to belong to different **classes**. 

Data frame and list are designed to belong to two different S3 classes in R. This can be checked by using `class(data.frame())` and `class(list())`.

```{r}
class(data.frame())
class(list())
```

However, if you call `unclass(data.frame())`, you will see that data frame is actually just a named list with some additional attributes, which means they are two of the similar kind. 

```{r}
unclass(data.frame())
```



So, why would they belong to different S3 classes? It is possibly because they are two different data structures and are expected to behave differently. Data frame is a two-dimensional-like structure, while list is a dynamic array-like data structure. In terms of the associated behaviors, one obvious example is data frame has the method `dim` to obtain the dimensions of the object, but list does not. 

- Objects are **instances** of classes. 

```{r echo = FALSE}
a <- data.frame(b = 1)
```

Let `a <- data.frame(b = 1)`, then `a` is an instance of class `data.frame`. 

```{r}
is(a, "data.frame")
```

Every instance has its own set of data and behaviors. Let `b <- data.frame(a = 2, b = 2)`, then both `b` and `a` are instances of class `data.frame`, but they have different sets of data.

## Inheritance and composition

Though data frame and list are two different kinds of objects, they still have commonalities. In fact, the result of `extends("data.frame", "list")` shows that list is a super class of data frame (this is a bit controversial, see https://stackoverflow.com/questions/19607652/why-doesnt-classdata-frame-show-list-inheritance). 

```{r}
extends("data.frame", "list")
``` 

In other words, data frame **inherits** from list in R. 

- In OOP, **Inheritance** is probably the most famous and widely-used relationship. A class can inherit both attributes and methods from its parent class.

This gives us the ability to define family tree like class system. 

### Example

Suppose we need to design a simple management system for a company to record the salary of all employees, and provide mechanism to give pay raise. There are two kinds of staffs in this company, employee and manager. For manager, its team members also need to be recorded.

For this system, we could first define an `employee` class with two attributes `emp_id` (employee ID) and `salary`, and a method `pay_raise`, which could raise the salary of an employee by a certain amount.

Then, we need to define another class called `manager`. Note that managers are still employees, so we also need to keep track of their employee IDs and salary, and be able to give pay raise if needed. Therefore, it is clear that class `manager` needs to inherit from `employee`.

Finally, to keep track of a manager's team members, a new attribute called `team_members` is needed, which could be a list of `employee` objects.

- The act of collecting several objects in one object is called **composition**.

In this example, both inheritance and composition are used.

## Constructor and initializer

- **Constructor** is responsible for creating and initializing an object.

- **Initializer** is responsible for running codes on the object after the object has been built. 

Therefore, initializer can only be run after the constructor. Conventionally, user input will be taken by the initializer.

## `self`

There is nothing special about `self`. It is just a conventional name used inside the body of method to refer to an object itself. 

# Visage OOP system

```{r}
e <- visage::new_class(class_name = "new")
lobstr::tree(e)
```

```{r}
visage::register_method(e, a = function() 1 + 2)
lobstr::tree(e)
```

