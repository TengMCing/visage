---
title: "visage OOP system"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{visage-OOP}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

**OOP** has been heavily used in R via the S3 system. However, users who have learned OOP in other languages are often dissatisfied with its syntax. This vignette introduces an OOP system provided by the `visage` package, which tries to implement a lightweight OOP system with python-like syntax in R using the "environment" language feature. 

<!-- This OOP system is developed primarily for the ease of designing, simulating, and evaluating visual inference experiment.  -->

There is another OOP system in R called [R6](https://r6.r-lib.org/index.html), which is also implemented using environment but in a different way. 

# Structure of this vignette

The first section will review some essential concepts of OOP, if you are familiar with them, you can safely skip it.

# OOP concepts review

**OOP** stands for **object-oriented programming**, which is a programming paradigm based on **objects**. Usually, object is defined as a special type of data structure that can hold both **attributes** (data) and **methods** (associated behaviours). 

## Class and instance

- Different kinds of objects are designed to belong to different **classes**. 

Data frame and list are designed to belong to two different S3 classes in R. This can be checked by using `class(data.frame())` and `class(list())`.

```{r}
class(data.frame())
class(list())
```

However, if you call `unclass(data.frame())`, you will see that data frame is actually just a named list with some additional attributes, which means they are two of the similar kind. 

```{r}
unclass(data.frame())
```



So, why would they belong to different S3 classes? It is possibly because they are two different data structures and are expected to behave differently. Data frame is a two-dimensional-like structure, while list is a dynamic array-like data structure. In terms of the associated behaviours, one obvious example is data frame has the method `dim` to obtain the dimensions of the object, but list does not. 

- Objects are **instances** of classes. 

```{r echo = FALSE}
a <- data.frame(b = 1)
```

Let `a <- data.frame(b = 1)`, then `a` is an instance of class `data.frame`. 

```{r}
is(a, "data.frame")
```

Every instance has its own set of data and behaviours. Let `b <- data.frame(a = 2, b = 2)`, then both `b` and `a` are instances of class `data.frame`, but they have different sets of data.

## Inheritance and composition

Though data frame and list are two different kinds of objects, they still have commonalities. In fact, the result of `extends("data.frame", "list")` shows that list is a super class of data frame (this is a bit controversial, see https://stackoverflow.com/questions/19607652/why-doesnt-classdata-frame-show-list-inheritance). 

```{r}
extends("data.frame", "list")
``` 

In other words, data frame **inherits** from list in R. 

- In OOP, **Inheritance** is probably the most famous and widely-used relationship. A class can inherit both attributes and methods from its parent class.

This gives us the ability to define family tree like class system. 

### Example

Suppose we need to design a simple management system for a company to record the salary of all employees, and provide mechanism to give pay raise. There are two kinds of staffs in this company, employee and manager. For manager, its team members also need to be recorded.

For this system, we could first define an `employee` class with two attributes `emp_id` (employee ID) and `salary`, and a method `pay_raise`, which could raise the salary of an employee by a certain amount.

Then, we need to define another class called `manager`. Note that managers are still employees, so we also need to keep track of their employee IDs and salary, and be able to give pay raise if needed. Therefore, it is clear that class `manager` needs to inherit from `employee`.

Finally, to keep track of a manager's team members, a new attribute called `team_members` is needed, which could be a list of `employee` objects.

- The act of collecting several objects in one object is called **composition**.

In this example, both inheritance and composition are used.

## Constructor and initializer

- **Constructor** is responsible for creating and initializing an object.

- **Initializer** is responsible for running codes on the object after the object has been built. 

Therefore, initializer can only be run after the constructor. Conventionally, user input will be taken by the initializer.

## `self`

There is nothing special about `self`. It is just a conventional name used inside the body of method to refer to an object itself. 

# `visage` OOP system

`visage` OOP system builds upon the R language feature - "environment". For more details about this language feature, please check the R Documentation `help(environment)`. 

Every `visage` class and instance are environments with S3 class `visage_oop`. For example, the `BASE` class provided by the package is an environment.

```{r}
library(visage)
str(BASE)
```

## Define a new class

To define a new class, we need to use the function `new_class()` with a class name passed to the `class_name` argument. The output shows that it is an unknown object. This is because the S3 method `print.visage_oop` can not find the `..str..()` method from the class. Similar to `__str__()` in Python, `..str..()` is responsible for providing a nicely printable string representation of an object. We will elaborate this behaviour in section ?.

```{r}
new_class(class_name = "DEMO")
```

If no environment is provided to `new_class()` via argument `env`, then it will automatically new an environment with the current environment as the parent environment.

So, if `new_class()` is run in the global environment, then the parent environment of the `DEMO` class is the global environment.

```{r}
parent.env(new_class(class_name = "DEMO"))
```

And if `new_class()` is run in an environment associated with a function, then the parent environment of the `DEMO` class is that environment.

```{r}
(function() {
  print(environment())
  parent.env(new_class(class_name = "DEMO"))
})()
```

If an environment is provided via `env`, `new_class()` will adopt that environment as `DEMO` class.

```{r}
e <- new.env()
print(e)
str(new_class(env = e, class_name = "DEMO"))
```


## Define methods

You may notice that the basic usage of `new_class()` only provides a class with very few attributes. Let's explore the structure of the `DEMO` class with `lobstr::tree`. According to the result, the class only contains three attributes, a character vector `..class..` representing the class list, a string `..type..` representing the type and a Boolean value `..instantiated..` representing the instantiated state.

```{r}
DEMO <- new_class(class_name = "DEMO")
lobstr::tree(DEMO)
```

It does not have any methods, nor any mechanism to run methods. To define some methods for this empty class, we need to use `register_method()`. 

Here, we tell the function we want to register a method called `myfunc` in the environment `DEMO`, and the method `myfunc` is a copy of the function `foo`. Then, the method can be called by `DEMO$myfunc()`.

```{r}
a <- "Hello, world!"

foo <- function() {
  a
}

register_method(DEMO, myfunc = foo)

DEMO$myfunc()
```

It seems like `register_method` only makes a copy of the function `foo` and stores it in `DEMO`. But it does more than that. If we check the structure again we will see `DEMO` now contains another environment called `..method_env..`, which contains an environment `self` that is identical to `DEMO`. You may ask what is the point of having this complex structure.

```{r}
lobstr::tree(DEMO)
```

Most R functions need to associate with a certain environment, such that values of variables can be determined. For example, the associated environment of `foo` is the global environment. So if `foo` can not find the variable `a` from the current scope, it can try to find it from the global scope.

```{r}
environment(foo)
```

The environment associated with the method `myfunc` is `..method_env..`. Using the same logic, when `myfunc` can not find a variable, it will try to find that variable in `..method_env..` first, then in the parent environment of `..method_env..`, etc. 

```{r}
print(DEMO$..method_env..)
environment(DEMO$myfunc)
```

This enables us to define class method or instance method. Consider the following code chunk. We define a method `add_one` that needs to access a variable `self`. Since `self` can not be found in the current scope, the function will try to find it in `..method_env..`, where `self` is a reference to `DEMO`.

```{r}
DEMO$inc <- 1

add_1 <- function() {
  self$inc <- self$inc + 1
}

register_method(DEMO, add_one = add_1)
```

Therefore, when the method `add_one()` is called, `DEMO$inc` will increase by 1.

```{r}
DEMO$add_one()
print(DEMO$inc)

DEMO$add_one()
DEMO$inc
```

